/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MysqlParser.jj */
/*@egen*/options {
	JDK_VERSION = "1.5";
	IGNORE_CASE=true ;
	DEBUG_PARSER=false ;
   	                               
   	                    
   	                     
   	             
	                
	                         
   	STATIC = false;
   	//NODE_CLASS = "com.meidusa.amoeba.mysql.parser.data.MysqlSimpleNode";
}

PARSER_BEGIN(MysqlParser)

/*
 * Copyright (C) 2008 Struct chen <piratebase@sina.com>
 * 	This program is free software; you can redistribute it and/or modify it under the terms of 
 * the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, 
 * or (at your option) any later version. 
 * 
 * 	This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details. 
 * 	You should have received a copy of the GNU General Public License along with this program; 
 * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package com.meidusa.amoeba.mysql.parser.sql;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

import com.meidusa.amoeba.parser.dbobject.*;
import com.meidusa.amoeba.parser.expression.*;
import com.meidusa.amoeba.parser.function.*;
import com.meidusa.amoeba.parser.Parser;
import com.meidusa.amoeba.parser.statement.*;
import com.meidusa.amoeba.parser.statement.ddl.*;
import com.meidusa.amoeba.parser.AmoebaSqlHintPropNames;


import java.math.BigDecimal;
import java.util.Map;
import java.util.HashMap;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Calendar;

import java.sql.Connection;
import com.meidusa.amoeba.sqljep.function.Comparative;
import com.meidusa.amoeba.util.StringUtil;
import com.meidusa.amoeba.util.Tuple;

import com.meidusa.amoeba.seq.fetcher.SeqFetchService;
import com.meidusa.amoeba.seq.fetcher.SeqConstants;

import com.meidusa.amoeba.mysql.parser.MysqlSyntaxConstants;

import org.apache.log4j.Logger;

public class MysqlParser implements/*@bgen(jjtree)*/ MysqlParserTreeConstants, /*@egen*/ com.meidusa.amoeba.parser.Parser{/*@bgen(jjtree)*/
  protected JJTMysqlParserState jjtree = new JJTMysqlParserState();

/*@egen*/
	private final static String metachars = "tnrbf\\\"";
	private final static String chars = "\t\n\r\b\f\\\"";
	
	private int parameterIndex = 0;
	private Map<String,Table> tableAliasMap = new HashMap<String,Table>();
	private Stack<Table> tableStack = new Stack<Table>();
	private Statement statement;
	private Schema defaultSchema;
	private String userName;
	private Map<String,Function> functionMap;
	private static TimeConverter timeConverter = new TimeConverter();

    private final  static Logger  logger = Logger.getLogger(MysqlParser.class);
	
	
	public void setFunctionMap(Map<String,Function> map){
		this.functionMap = map;
	}

	public void setDefaultSchema(Schema schema){
		defaultSchema = schema;
	}

	public void setUserName(String userName)
	{
	  this.userName = userName;
	}
	
    /**
     * main method to test parser
     */
    public static void main( String args[] )
        throws com.meidusa.amoeba.parser.ParseException
        {

        MysqlParser p = null ;
        if ( args.length < 1  ) {
            System.out.println("Reading from stdin") ;
            p = new MysqlParser(System.in) ;
        }
        else {
            try {
                p = new MysqlParser(new DataInputStream(
                                new FileInputStream(args[0]))) ;
            }
            catch (FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new MysqlParser(System.in) ;
            }
        } // else ends here

        if ( args.length > 0 ) {
            System.out.println(args[0]) ;
        }
        Statement statement = p.doParse();
        System.out.println(statement.getExpression());

    } // main ends here

   void jjtreeOpenNodeScope(Node n){
      //((SimpleNode)n).setFirstToken(getToken(1));
    }

   void jjtreeCloseNodeScope(Node n){
       // ((SimpleNode)n).setLastToken(token);
    }
    
	Function getFunction(String indent){
		if(functionMap == null){
			return null;	
		}else{
		  Function function = functionMap.get(indent);	
		  if(function instanceof ThreadLocalSettingFunction)
		  {
			((ThreadLocalSettingFunction)function).invoke();
		  }
			return function;
		}
		//return funMap.get(indent);
	}
	
	
	
	public Statement doParse() throws com.meidusa.amoeba.parser.ParseException{
		try{
			Statement statement = this.parse();
			return statement;
		}catch(Exception e){
			throw new com.meidusa.amoeba.parser.ParseException(e);
		}
	}
	public Statement getParsedStatement(){
		return statement;
	}

	public Expression replaceNextOrCurrSequenceValue(Expression expression, DMLStatement statement)
	{
		if(expression instanceof ColumnExpression)
  		{
			Column column = ((ColumnExpression)expression).getColumn();
			String columnName = column.getName();

			if(defaultSchema != null && !StringUtil.isEmpty(defaultSchema.getName()))
			{
			  if(column.getTable() != null &&
		   		!StringUtil.isEmpty(column.getTable().toString()) &&
		   		!StringUtil.isEmpty(column.getTable().getName()) &&
		   		!StringUtil.isEmpty(columnName))
				{
			  		if(columnName.equalsIgnoreCase(SeqConstants.NEXTVAL) || columnName.equalsIgnoreCase(SeqConstants.CURRVAL))
			  		{
						// replace global sequence
						String schemaName = defaultSchema.getName();
            			String currOrNext = columnName;
            			String seqName = column.getTable().getName();

            		
			  	  		Long seqValue = -1l;
			  	  		if(currOrNext.equalsIgnoreCase(SeqConstants.NEXTVAL))
			  	  		{
			  	  		  	try
			  	  		  	{
								seqValue = SeqFetchService.getSeqNextVal(schemaName, seqName);
			  	  		  	}
			  	  		  	catch(Exception e)
			  	  		  	{
			  	  		  	  	logger.error(String.format("fetch global sequence %s next value error since:%s", seqName, e.getMessage() ));
			  	  		  	}
			  	  		}
			  	  		else if(currOrNext.equalsIgnoreCase(SeqConstants.CURRVAL))
			  	  		{
			  	  		  	try
			  	  		  	{
								seqValue = SeqFetchService.getSeqCurrVal(schemaName, seqName);
			  	  		  	}
			  	  		  	catch(Exception e)
			  	  		  	{
			  	  		  	  	logger.error(String.format("fetch global sequence %s current value error since:%s", seqName, e.getMessage() ));
			  	  		  	}
			  	  		}

						if(seqValue > 0)
						{
							expression = new ConstantExpression(seqValue);
						}
						
						String globalSeqName = column.toString();
	    				int seqTokenEndColumn = getToken(0).endColumn;
	    				GlobalSeqColumn< Column> gloabSeq = new GlobalSeqColumn< Column>(column, globalSeqName, seqValue, seqTokenEndColumn);
						

						if(statement != null)
						{
							statement.addSeqColumn(gloabSeq);
						}	
						// seq name should not add to route table map
						tableAliasMap.remove(column.getTable().toString());
					}
				}
			}
		}

		return expression;
	}

	public void replaceBatchSeqValue(FunctionExpression funExp, DMLStatement statement)
	{
		if(defaultSchema != null && !StringUtil.isEmpty(defaultSchema.getName()))
		{
			BulkValFuntion bulkValFunc = (BulkValFuntion)funExp.getFunction();

		  	if( bulkValFunc.getTable() != null &&
	   		!StringUtil.isEmpty(bulkValFunc.getTable().toString()) &&
			!StringUtil.isEmpty(bulkValFunc.getTable().getName())
	   		)
	   		{
		   		String schemaName = defaultSchema.getName();
	            String seqName = bulkValFunc.getTable().getName();
	
			  	List<Expression> args = funExp.getArgList();
	            int argCount = -1;
	
	            try {
	              Expression countExp = args.get(0);
	              argCount = Integer.parseInt(String.valueOf( countExp.evaluate(null)));
	            } catch (Exception e) {
	              logger.error(String.format("can not parse bulkval function arg to integer number since: %s", e.getMessage()) );
	            }
	
				Long seqValue = -1l;
	            if (argCount > 0) {
	              try
	              {
					seqValue = SeqFetchService.batchGetSeqVal(schemaName, seqName, argCount);
	              }
	              catch (Exception e)
	              {
			  	  	logger.error(String.format("batch fetch global sequence %s current value error since:%s", seqName, e.getMessage() ));
	              }
	            }

				String bulkFunName = funExp.getFunction().getName();
	    		int seqTokenEndColumn = getToken(0).endColumn;
	    		GlobalSeqColumn< FunctionExpression> gloabSeq = new GlobalSeqColumn< FunctionExpression>(funExp, bulkFunName, seqValue, seqTokenEndColumn);

				if(statement != null)
				{
	           		statement.addBatchSeqFetchCall(gloabSeq);
				}
	            // seq name should not add to route table map
				tableAliasMap.remove(bulkValFunc.getTable().toString());
	   		}
		}
	}
	
	private Expression reverseExpression(boolean not,Expression expression){
		if(not){
			if(expression != null){
				return expression.reverse();
			}else{
				return null;
			}
		}else{
			return expression;
		}
	}
	
	private static String replaceEscape(String inputStr) {
		int len = inputStr.length();
		int p = 0;
		int i;
		
		StringBuilder output = new StringBuilder();
		
		while ((i = inputStr.indexOf('\\', p)) != -1) {
			output.append(inputStr.substring(p, i));
			
			if (i+1 == len) break;
			
			// find metacharacter
			char metac = inputStr.charAt(i+1);

			// find the index of the metac
			int k = metachars.indexOf(metac);
			if (k == -1) {
				// didn't find the metachar, leave sequence as found.
				// This code should be unreachable if the parser
				// is functioning properly because strings containing
				// unknown escape characters should not be accepted.
				output.append('\\');
				output.append(metac);
			} else {
				// its corresponding true char
				output.append(chars.charAt(k));   
			}

			// skip over both escape character & metacharacter
			p = i + 2;
		}

		// add the end of the input string to the output
		if (p < len)
			output.append(inputStr.substring(p));
		return output.toString();
	}
} // class MysqlParser ends here

PARSER_END(MysqlParser)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

/* Prefix      Meaning
    -------------------
    K_          Keyword
    O_          Operator
    S_          Substitutes
*/

TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */
{
	<K_DONET: "@">
|    <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_AS: "AS">
|   <K_BETWEEN:"BETWEEN">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BY:"BY">
|   <K_CASE:"CASE">
|   <K_CAST:"CAST">
|   <K_CHAR:"CHAR">
|   <K_CHARACTER:"CHARACTER">

|   <K_DECIMAL:"DECIMAL">
|   <K_DEC:"DEC">
|   <K_DELETE:"DELETE">
|   <K_DISTINCT:"DISTINCT">
|   <K_DO:"DO">
|   <K_DOUBLE:"DOUBLE">
|   <K_DROP:"DROP">
|   <K_ELSE:"ELSE">
|   <K_ELSEIF:"ELSEIF">
|   <K_END:"END">
|   <K_ESCAPE:"ESCAPE">
|   <K_EXISTS:"EXISTS">
|   <K_FETCH:"FETCH">
|   <K_FLOAT:"FLOAT">
|   <K_FOR:"FOR">
|   <K_FROM:"FROM">
|   <K_FULL:"FULL">
|   <K_GROUP:"GROUP">
|   <K_HAVING:"HAVING">
|   <K_IN:"IN">
|   <K_IS:"IS">
|   <K_INTO:"INTO">
|   <K_INDEX:"INDEX">
|   <K_INNER:"INNER">
|   <K_INSERT:"INSERT">
|	<K_REPLACE:"REPLACE">
|   <K_INTEGER:"INTEGER">
|   <K_INT:"INT">
|   <K_JOIN:"JOIN">
|   <K_LEFT:"LEFT">
| 	< K_NATURAL: "NATURAL" >
| 	< K_CROSS : "CROSS" >
|   <K_LIKE:"LIKE">
|   <K_LOCK:"LOCK">
|   <K_LOOP:"LOOP">
|   <K_CREATE:"CREATE">
|   <K_NOT:"NOT">
| 	<K_NOT2:"!" >
|   <K_NULL:"NULL">
|   <K_NULLS:"NULLS">
|   <K_NUMBER:"NUMBER">
|   <K_NUMERIC:"NUMERIC">
|   <K_OF:"OF">
|   <K_ON:"ON">
|	<K_NOWAIT:"NOWAIT">
|   <K_ONLY:"ONLY">
|   <K_OR:"OR">
|   <K_OR2:"||">
|   <K_ORDER:"ORDER">
|   <K_OUTER:"OUTER">
|   <K_QUERYNO:"QUERYNO">
|   <K_OPTIMIZE:"OPTIMIZE">
|   <K_READ:"READ">
|   <K_REAL:"REAL">
|	<K_OPTION:"OPTION">
|   <K_OFFSET:"OFFSET">
|  <K_EXPLAIN:"EXPLAIN">
| 	< K_EXTENDED:"EXTENDED" >
|   <K_SELECT:"SELECT">
|   <K_SET:"SET">
|   <K_XA:"XA" >
|   <K_SOME:"SOME">
|   <K_TABLE:"TABLE">
|	<K_SHOW:"SHOW" | "DESCRIBE">
|   <K_MOD:"MOD">
|	<K_DIV:"DIV">
|   <K_THEN:"THEN">
|   <K_TO:"TO">
|   <K_UNION:"UNION">
|   <K_UNIQUE:"UNIQUE">
|   <K_UPDATE:"UPDATE">
|   <K_USE:"USE">
|   <K_USING:"USING">
|   <K_VALUES:"VALUES">
|   <K_VARCHAR2:"VARCHAR2">
|   <K_VARCHAR:"VARCHAR">
|   <K_WHEN:"WHEN">
|   <K_WHERE:"WHERE">
|   <K_WHILE:"WHILE">
|   <K_WITH:"WITH">
|	<K_TRUE: "TRUE">
|	<K_FALSE: "FALSE">
|	<K_LIMIT: "LIMIT">
|   <K_RIGHT:"RIGHT">
|   <K_INTERVAL:"INTERVAL">
|   <K_YEAR:"YEAR">
|   <K_MICROSECOND:"MICROSECOND">
|   <K_SECOND:"SECOND">
|   <K_DAY:"DAY">
|   <K_MINUTE:"MINUTE">
|   <K_MONTH:"MONTH">
|   <K_HOUR:"HOUR">
|	<K_COMMIT:"COMMIT">
|   <K_BEGIN:"BEGIN">
|	<K_ROLLBACK:"ROLLBACK">
| 	< K_DESC: "desc" >
|   <K_ASC:"asc">
| < K_IGNORE_INDEX:"IGNORE INDEX" >
| < K_FORCE_INDEX:"FORCE INDEX" >
|	<K_TRANSACTION_ISOLATION_LEVEL:"TRANSACTION ISOLATION LEVEL">
| 	<K_DUPLICATE:"DUPLICATE" >
| 	<K_KEY :"KEY" >
| 	< K_KEYS: "KEYS" >
|	<K_START_TRANSACTION:"START TRANSACTION">
|	<K_SESSION:"SESSION">

|	<K_TRANSACTION_READ_COMMITTED:"READ COMMITTED">
|	<K_TRANSACTION_READ_UNCOMMITTED:"READ UNCOMMITTED">
|	<K_TRANSACTION_REPEATABLE_READ:"REPEATABLE READ">
|	<K_TRANSACTION_SERIALIZABLE:"SERIALIZABLE">
|	<K_CLIENT_CHARSET:"CLIENT CHARSET">
|   <K_SHOW_FULL_TABLES:"FULL TABLES" | "TABLES" >
| 	<K_SHOW_OPEN_TABLES:"OPEN TABLES" >
| 	<K_SHOW_CREATE_PROCEDURE:"CREATE PROCEDURE" >
| 	<K_SHOW_CREATE_DATABASE :"CREATE DATABASE" | "CREATE SCHEMA" >
|   <K_SHOW_FULL_COLUMNS:"FULL COLUMNS"| "COLUMNS" | "FULL FIELDS" | "FIELDS">
| 	<K_TABLE_STATUS:"TABLE STATUS" >
| 	<K_VARIABLES:"VARIABLES" >
|   < K_GRANTS_FOR:"GRANTS FOR" >
|   < K_TRIGGERS:"TRIGGERS" >
| 	< K_PROCEDURE:"PROCEDURE" >
|   < K_EVENTS:"EVENTS" >
| 	<K_CALL:"CALL" >
| 	< K_CHARACTER_SET :"CHARACTER SET" >

| 	<K_IF_NOT_EXISTS: "IF NOT EXISTS" >
| 	<K_IF_EXISTS:"IF EXISTS" >
|  	<K_PRIMARY: "PRIMARY">
| 	<K_TRUNCATE : "TRUNCATE" >
| 	<K_VIEW :"VIEW" >
| 	<K_DATABASE : "DATABASE" | "SCHEMA" >
| 	<K_SEQUENCE : "SEQUENCE" >
| 	<K_TRIGGER :"TRIGGER " >
| 	<K_FUNCTION :"FUNCTION " | "PROCEDURE" >
| 	<K_TEMPORARY:"TEMPORARY" | "TEMP" >
| 	<K_GLOBAL : "GLOBAL" >
| 	<K_LOCAL : "LOCAL" >
| 	< K_RENAME : "RENAME" >
| 	< K_ALTER : "ALTER" >
| 	<K_IGNORE : "IGNORE">

|  < K_HELP : "HELP" >

| < K_DISTINCTROW : "DISTINCTROW" >
| < K_HIGH_PRIORITY : "HIGH_PRIORITY" >
| < K_STRAIGHT_JOIN : "STRAIGHT_JOIN" >
| < K_SQL_SMALL_RESULT : "SQL_SMALL_RESULT" >
| < K_SQL_BIG_RESULT : "SQL_BIG_RESULT" >
| < K_SQL_BUFFER_RESULT : "SQL_BUFFER_RESULT" >
| < K_SQL_CACHE : "SQL_CACHE" >
| < K_SQL_NO_CACHE : "SQL_NO_CACHE">
| < K_SQL_CALC_FOUND_ROWS : "SQL_CALC_FOUND_ROWS">

|<K_ACCESSIBLE : "ACCESSIBLE" >
|<K_BEFORE : "BEFORE" >
|<K_BINARY : "BINARY" >
|<K_COLUMN : "COLUMN" >
|<K_CONTINUE : "CONTINUE" >
|<K_CURRENT_TIMESTAMP : "CURRENT_TIMESTAMP" >
|<K_DAY_MICROSECOND : "DAY_MICROSECOND" >
|<K_DEFAULT : "DEFAULT" >
|<K_EACH : "EACH" >
|<K_ENCLOSED : "ENCLOSED" >
|<K_EXIT : "EXIT" >
|<K_FLOAT8 : "FLOAT8" >
|<K_FOREIGN : "FOREIGN" >
|<K_GRANT : "GRANT" >
|<K_HOUR_SECOND : "HOUR_SECOND" >
|<K_INT2 : "INT2" >
|<K_INT8 : "INT8" >
|<K_KILL : "KILL" >
|<K_LINEAR : "LINEAR" >
|<K_LOCALTIME : "LOCALTIME" >
|<K_LONG : "LONG" >
|<K_MATCH : "MATCH" >
|<K_MEDIUMINT : "MEDIUMINT" >
|<K_MINUTE_MICROSECOND : "MINUTE_MICROSECOND" >
|<K_MODIFIES : "MODIFIES" >
|<K_NO_WRITE_TO_BINLOG : "NO_WRITE_TO_BINLOG" >
|<K_OPTIONALLY : "OPTIONALLY" >
|<K_OUT : "OUT" >
|<K_PRECISION : "PRECISION" >
|<K_PURGE : "PURGE" >
|<K_READS : "READS" >
|<K_REFERENCES : "REFERENCES" >
|<K_REQUIRE : "REQUIRE" >
|<K_RETURN : "RETURN" >
|<K_RLIKE : "RLIKE" >
|<K_SECOND_MICROSECOND : "SECOND_MICROSECOND" >
|<K_SEPARATOR : "SEPARATOR" >
|<K_SIGNAL : "SIGNAL" >
|<K_SPECIFIC : "SPECIFIC" >
|<K_SQLSTATE : "SQLSTATE" >
|<K_STARTING : "STARTING" >
|<K_TERMINATED : "TERMINATED" >
|<K_TINYINT : "TINYINT" >
|<K_TRAILING : "TRAILING" >
|<K_UNDO : "UNDO" >
|<K_UNLOCK : "UNLOCK" >
|<K_USAGE : "USAGE" >
|<K_UTC_DATE : "UTC_DATE" >
|<K_VARCHARACTER : "VARCHARACTER" >
|<K_WRITE : "WRITE" >
|<K_ZEROFILL : "ZEROFILL" >

| <K_ADD : "ADD" >
| <K_ANALYZE : "ANALYZE" >
| <K_BLOB : "BLOB" >
| <K_CHANGE : "CHANGE" >
| <K_CHECK : "CHECK" >
| <K_CONDITION : "CONDITION" >
| <K_CONVERT : "CONVERT" >
| <K_CURRENT_DATE : "CURRENT_DATE" >
| <K_CURRENT_USER : "CURRENT_USER" >
| <K_DATABASES : "DATABASES" >
| <K_DAY_MINUTE : "DAY_MINUTE" >
| <K_DELAYED : "DELAYED" >
| <K_ESCAPED : "ESCAPED" >

| <K_HOUR_MICROSECOND : "HOUR_MICROSECOND" >
| <K_IF : "IF" >
| <K_INOUT : "INOUT" >
| <K_INT3 : "INT3" >
| <K_LEADING : "LEADING" >
| <K_LINES : "LINES" >
| <K_LOCALTIMESTAMP : "LOCALTIMESTAMP" >
| <K_LONGBLOB : "LONGBLOB" >
| <K_LOW_PRIORITY : "LOW_PRIORITY" >
| <K_MAXVALUE : "MAXVALUE" >
| <K_MEDIUMTEXT : "MEDIUMTEXT" >
| <K_MINUTE_SECOND : "MINUTE_SECOND" >

| <K_RANGE : "RANGE" >
| <K_READ_WRITE : "READ_WRITE" >
| <K_REGEXP : "REGEXP" >
| <K_REPEAT : "REPEAT" >
| <K_RESIGNAL : "RESIGNAL" >
| <K_REVOKE : "REVOKE" >
| <K_SMALLINT : "SMALLINT" >
| <K_SQL : "SQL" >
| <K_SQLWARNING : "SQLWARNING" >
| <K_TINYTEXT : "TINYTEXT" >
| <K_UNSIGNED : "UNSIGNED" >
| <K_UTC_TIME : "UTC_TIME" >
| <K_VARBINARY : "VARBINARY" >
| <K_VARYING : "VARYING" >
| <K_XOR : "XOR" >

| <K_ASENSITIVE : "ASENSITIVE" >
| <K_BIGINT : "BIGINT" >
| <K_BOTH : "BOTH" >
| <K_CASCADE : "CASCADE" >
| <K_COLLATE : "COLLATE" >
| <K_CONSTRAINT : "CONSTRAINT" >
| <K_CURRENT_TIME : "CURRENT_TIME" >
| <K_CURSOR : "CURSOR" >
| <K_DAY_HOUR : "DAY_HOUR" >
| <K_DAY_SECOND : "DAY_SECOND" >
| <K_DECLARE : "DECLARE" >
| <K_DETERMINISTIC : "DETERMINISTIC" >
| <K_DUAL : "DUAL" >
| <K_FLOAT4 : "FLOAT4" >
| <K_FORCE : "FORCE" >
| <K_FULLTEXT : "FULLTEXT" >
| <K_HOUR_MINUTE : "HOUR_MINUTE" >
| <K_INFILE : "INFILE" >
| <K_INSENSITIVE : "INSENSITIVE" >
| <K_INT1 : "INT1" >
| <K_INT4 : "INT4" >
| <K_ITERATE : "ITERATE" >
| <K_LEAVE : "LEAVE" >
| <K_LOAD : "LOAD" >
| <K_LONGTEXT : "LONGTEXT" >
| <K_MASTER_SSL_VERIFY_SERVER_CERT : "MASTER_SSL_VERIFY_SERVER_CERT" >
| <K_MEDIUMBLOB : "MEDIUMBLOB" >
| <K_MIDDLEINT : "MIDDLEINT" >

| <K_OUTFILE : "OUTFILE" >
| <K_RELEASE : "RELEASE" >
| <K_RESTRICT : "RESTRICT" >
| <K_SCHEMAS : "SCHEMAS" >
| <K_SENSITIVE : "SENSITIVE" >
| <K_SPATIAL : "SPATIAL" >
| <K_SQLEXCEPTION : "SQLEXCEPTION" >
| <K_SSL : "SSL" >
| <K_TINYBLOB : "TINYBLOB" >

| <K_UTC_TIMESTAMP : "UTC_TIMESTAMP" >
| <K_YEAR_MONTH : "YEAR_MONTH" >

}

TOKEN : /* Numeric Constants */
{
	< INTEGER_LITERAL: ( <DIGIT> )+ >
	|
	< FLOATING_POINT_LITERAL:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
|
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
	<#DIGIT: [
				"0" - "9",
				"\u0660" - "\u0669",
				"\u06f0" - "\u06f9",
				"\u0966" - "\u096f",
				"\u09e6" - "\u09ef",
				"\u0a66" - "\u0a6f",
				"\u0ae6" - "\u0aef",
				"\u0b66" - "\u0b6f",
				"\u0be7" - "\u0bef",
				"\u0c66" - "\u0c6f",
				"\u0ce6" - "\u0cef",
				"\u0d66" - "\u0d6f",
				"\u0e50" - "\u0e59",
				"\u0ed0" - "\u0ed9",
				"\u0f20" - "\u0f29",
				"\uff10" - "\uff19"
			]>
}

 // \u6fb6\u6c33\ue511\u5a09\u3129\u5674\u6d93\u5d86\u656e\u93b8\ufffd
SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
}

TOKEN:
{

< IDENTIFIER: (([ "@"])*( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)*) >
| 	<#LETTER: [
				"a"-"z",
				"A"-"Z",
				"\u00aa",
				"\u00b5",
				"\u00ba",
				"\u00c0" - "\u00d6",
				"\u00d8" - "\u00f6",
				"\u00f8" - "\u01f5",
				"\u01fa" - "\u0217",
				"\u0250" - "\u02a8",
				"\u02b0" - "\u02b8",
				"\u02bb" - "\u02c1",
				"\u02d0" - "\u02d1",
				"\u02e0" - "\u02e4",
				"\u037a",
				"\u0386",
				"\u0388" - "\u038a",
				"\u038c",
				"\u038e" - "\u03a1",
				"\u03a3" - "\u03ce",
				"\u03d0" - "\u03d6",
				"\u03da",
				"\u03dc",
				"\u03de",
				"\u03e0",
				"\u03e2" - "\u03f3",
				"\u0401" - "\u040c",
				"\u040e" - "\u044f",
				"\u0451" - "\u045c",
				"\u045e" - "\u0481",
				"\u0490" - "\u04c4",
				"\u04c7" - "\u04c8",
				"\u04cb" - "\u04cc",
				"\u04d0" - "\u04eb",
				"\u04ee" - "\u04f5",
				"\u04f8" - "\u04f9",
				"\u0531" - "\u0556",
				"\u0559",
				"\u0561" - "\u0587",
				"\u05d0" - "\u05ea",
				"\u05f0" - "\u05f2",
				"\u0621" - "\u063a",
				"\u0640" - "\u064a",
				"\u0671" - "\u06b7",
				"\u06ba" - "\u06be",
				"\u06c0" - "\u06ce",
				"\u06d0" - "\u06d3",
				"\u06d5",
				"\u06e5" - "\u06e6",
				"\u0905" - "\u0939",
				"\u093d",
				"\u0958" - "\u0961",
				"\u0985" - "\u098c",
				"\u098f" - "\u0990",
				"\u0993" - "\u09a8",
				"\u09aa" - "\u09b0",
				"\u09b2",
				"\u09b6" - "\u09b9",
				"\u09dc" - "\u09dd",
				"\u09df" - "\u09e1",
				"\u09f0" - "\u09f1",
				"\u0a05" - "\u0a0a",
				"\u0a0f" - "\u0a10",
				"\u0a13" - "\u0a28",
				"\u0a2a" - "\u0a30",
				"\u0a32" - "\u0a33",
				"\u0a35" - "\u0a36",
				"\u0a38" - "\u0a39",
				"\u0a59" - "\u0a5c",
				"\u0a5e",
				"\u0a72" - "\u0a74",
				"\u0a85" - "\u0a8b",
				"\u0a8d",
				"\u0a8f" - "\u0a91",
				"\u0a93" - "\u0aa8",
				"\u0aaa" - "\u0ab0",
				"\u0ab2" - "\u0ab3",
				"\u0ab5" - "\u0ab9",
				"\u0abd",
				"\u0ae0",
				"\u0b05" - "\u0b0c",
				"\u0b0f" - "\u0b10",
				"\u0b13" - "\u0b28",
				"\u0b2a" - "\u0b30",
				"\u0b32" - "\u0b33",
				"\u0b36" - "\u0b39",
				"\u0b3d",
				"\u0b5c" - "\u0b5d",
				"\u0b5f" - "\u0b61",
				"\u0b85" - "\u0b8a",
				"\u0b8e" - "\u0b90",
				"\u0b92" - "\u0b95",
				"\u0b99" - "\u0b9a",
				"\u0b9c",
				"\u0b9e" - "\u0b9f",
				"\u0ba3" - "\u0ba4",
				"\u0ba8" - "\u0baa",
				"\u0bae" - "\u0bb5",
				"\u0bb7" - "\u0bb9",
				"\u0c05" - "\u0c0c",
				"\u0c0e" - "\u0c10",
				"\u0c12" - "\u0c28",
				"\u0c2a" - "\u0c33",
				"\u0c35" - "\u0c39",
				"\u0c60" - "\u0c61",
				"\u0c85" - "\u0c8c",
				"\u0c8e" - "\u0c90",
				"\u0c92" - "\u0ca8",
				"\u0caa" - "\u0cb3",
				"\u0cb5" - "\u0cb9",
				"\u0cde",
				"\u0ce0" - "\u0ce1",
				"\u0d05" - "\u0d0c",
				"\u0d0e" - "\u0d10",
				"\u0d12" - "\u0d28",
				"\u0d2a" - "\u0d39",
				"\u0d60" - "\u0d61",
				"\u0e01" - "\u0e2e",
				"\u0e30",
				"\u0e32" - "\u0e33",
				"\u0e40" - "\u0e46",
				"\u0e81" - "\u0e82",
				"\u0e84",
				"\u0e87" - "\u0e88",
				"\u0e8a",
				"\u0e8d",
				"\u0e94" - "\u0e97",
				"\u0e99" - "\u0e9f",
				"\u0ea1" - "\u0ea3",
				"\u0ea5",
				"\u0ea7",
				"\u0eaa" - "\u0eab",
				"\u0ead" - "\u0eae",
				"\u0eb0",
				"\u0eb2" - "\u0eb3",
				"\u0ebd",
				"\u0ec0" - "\u0ec4",
				"\u0ec6",
				"\u0edc" - "\u0edd",
				"\u0f40" - "\u0f47",
				"\u0f49" - "\u0f69",
				"\u10a0" - "\u10c5",
				"\u10d0" - "\u10f6",
				"\u1100" - "\u1159",
				"\u115f" - "\u11a2",
				"\u11a8" - "\u11f9",
				"\u1e00" - "\u1e9b",
				"\u1ea0" - "\u1ef9",
				"\u1f00" - "\u1f15",
				"\u1f18" - "\u1f1d",
				"\u1f20" - "\u1f45",
				"\u1f48" - "\u1f4d",
				"\u1f50" - "\u1f57",
				"\u1f59",
				"\u1f5b",
				"\u1f5d",
				"\u1f5f" - "\u1f7d",
				"\u1f80" - "\u1fb4",
				"\u1fb6" - "\u1fbc",
				"\u1fbe",
				"\u1fc2" - "\u1fc4",
				"\u1fc6" - "\u1fcc",
				"\u1fd0" - "\u1fd3",
				"\u1fd6" - "\u1fdb",
				"\u1fe0" - "\u1fec",
				"\u1ff2" - "\u1ff4",
				"\u1ff6" - "\u1ffc",
				"\u207f",
				"\u2102",
				"\u2107",
				"\u210a" - "\u2113",
				"\u2115",
				"\u2118" - "\u211d",
				"\u2124",
				"\u2126",
				"\u2128",
				"\u212a" - "\u2131",
				"\u2133" - "\u2138",
				"\u3005",
				"\u3031" - "\u3035",
				"\u3041" - "\u3094",
				"\u309b" - "\u309e",
				"\u30a1" - "\u30fa",
				"\u30fc" - "\u30fe",
				"\u3105" - "\u312c",
				"\u3131" - "\u318e",
				"\u4e00" - "\u9fa5",
				"\uac00" - "\ud7a3",
				"\uf900" - "\ufa2d",
				"\ufb00" - "\ufb06",
				"\ufb13" - "\ufb17",
				"\ufb1f" - "\ufb28",
				"\ufb2a" - "\ufb36",
				"\ufb38" - "\ufb3c",
				"\ufb3e",
				"\ufb40" - "\ufb41",
				"\ufb43" - "\ufb44",
				"\ufb46" - "\ufbb1",
				"\ufbd3" - "\ufd3d",
				"\ufd50" - "\ufd8f",
				"\ufd92" - "\ufdc7",
				"\ufdf0" - "\ufdfb",
				"\ufe70" - "\ufe72",
				"\ufe74",
				"\ufe76" - "\ufefc",
				"\uff21" - "\uff3a",
				"\uff41" - "\uff5a",
				"\uff66" - "\uffbe",
				"\uffc2" - "\uffc7",
				"\uffca" - "\uffcf",
				"\uffd2" - "\uffd7",
				"\uffda" - "\uffdc"
			]>
|   < #SPECIAL_CHARS: "$" | "_" >
|   < STRING_LITERAL: ( "_" <IDENTIFIER> | "x" )* ( ("'"( ( (~["'","\\"]) | ("\\"( ["n","t","b","r","f","0","\\","'","\""])) | ("\\"(~["'"])) )* )"'") | (  "\"" ((~["\""])| ("\\")|("\\" "\""))* "\""))>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
|	< S_COMMA_IDENTIFIER: "`" ((["@"])*( <LETTER> )+ ( <DIGIT> | "-"|<LETTER> |<SPECIAL_CHARS>)*) "`">
|   < S_PARAMETER_MARKER: "?" | "$(" <INTEGER_LITERAL> ")">

}

void parseParams(Map amoebaParameterMap)      :
{
	Token parameterToken = null;
	Object value = null;
	Token valueToken = null;
}
{
	(
		parameterToken = <IDENTIFIER> "="
		( valueToken= <K_TRUE> {value = Boolean.TRUE;}
		| valueToken= <K_FALSE> {value = Boolean.FALSE;}
		| valueToken = <INTEGER_LITERAL>{value = Integer.valueOf(valueToken.image);} 
		| valueToken = <STRING_LITERAL>{value = (valueToken.image).substring(1,valueToken.image.length()-1);}
		)
	)
	{
		amoebaParameterMap.put(parameterToken.image,value);
	}
}

Statement parse()      :
{
  
	Statement statement = null;
	Map amoebaParameterMap = null;
}
{
	(
		((("/*!" [< INTEGER_LITERAL >] | "/*" | "#") ["[" parseParams(amoebaParameterMap = new HashMap()) ( "," parseParams(amoebaParameterMap))* "]" ]  ["*/"]) ["("] statement=parserInner() [")"] [";"] ["*/"]) 
		|
		statement=parserInner() 
	)[(";" |<EOF>)]
{
  	if(statement instanceof AbstractStatement){
		/* amoeba parameters  */
		if(amoebaParameterMap != null)
		{
		  	statement.setHintParams(amoebaParameterMap);
		  	
			Boolean isRead = (Boolean)amoebaParameterMap.get(AmoebaSqlHintPropNames.IS_READ_HINT);
			if(isRead != null)
			{
			  if(statement instanceof DMLStatement)
			  {
				((DMLStatement)statement).setRead(isRead);
			  }
			}

			Boolean isProcedure = (Boolean)amoebaParameterMap.get(AmoebaSqlHintPropNames.IS_PROCEDURE_HINT);
			if(isProcedure != null)
			{
			  if(statement instanceof DMLStatement)
			  {
				((DMLStatement)statement).setProcedure(isProcedure);
			  }
			}
	
		}
  	}

  	/* amoeba parameters  */
	if(amoebaParameterMap != null)
	{
		Integer params = (Integer)amoebaParameterMap.get(AmoebaSqlHintPropNames.PARAMS_COUNT_HINT);
		if(params != null)
		{
			statement.setParameterCount(params);
		}else
		{
			statement.setParameterCount(parameterIndex);
		}
	}else
	{
		statement.setParameterCount(parameterIndex);
	}
	return statement;

}

}
Statement parserInner()      :
{
	Expression expression = null;
	Statement statement = null;
	Token parameterToken = null;
	Object value = null;
	Token valueToken = null;
	boolean isExplain = false;
}
{
   [<K_EXPLAIN>  { isExplain = true;} ]
   [< K_EXTENDED>](
    statement = DeleteQuery()
    |
    statement = InsertQuery()
    |
    statement= SelectQuery()
    |
    statement = UpdateQuery()
  	|
  	statement = ShowQuery()
 	|
 	statement = CallQuery()	 
    |
    statement = SelectSchema()
  	|
  	statement = DDLTruncateTableQuery()
  	|
  	statement = DDLCreateQuery()
  	|
  	statement = DDLDropQuery()
  	|
  	statement = DDLRenameTableQuery()
  	|
  	statement = DDLAlertTableQuery()
	|
 	< K_XA> statement = XaQuery(new XAStatement())
	|
	statement = SetQuery()
	|
	< K_HELP> statement = Help(new HelpStatement())
	| (<K_BEGIN>)	{	statement = new BeginStatement(); } 
    |(<K_COMMIT> /*[<K_WORK>] [<K_AND> [<K_NO>] <K_CHAIN>] [[<K_NO>] <K_RELEASE>]*/){statement = new CommitStatement();}
    |(<K_ROLLBACK>/*[<K_WORK>] [<K_AND> [<K_NO>] <K_CHAIN>] [[<K_NO>] <K_RELEASE>]*/){statement = new RollbackStatement();}
    |(<K_START_TRANSACTION>){statement = new StartTansactionStatement();}
    )
    [ INDEX() ]
    {
    	if(statement instanceof AbstractStatement){
	    	List<Table> list = new ArrayList<Table>();
			for(Map.Entry<String,Table> entry : tableAliasMap.entrySet()){
			  Table table = entry.getValue();
				if(!list.contains(table)){
					// associate user id with table
				  	if(userName != null)
				  	{
				  		table.setUserName(userName);
				 	}

				 	// use connection schema for routing
				 	if(defaultSchema != null)
				 	{
						table.setSchema(defaultSchema);
				 	}
					list.add(table);
				}
			}
			
			Table[] tables = new Table[list.size()];
			list.toArray(tables);
			((AbstractStatement)statement).setTables(tables);
    	}

		statement.setExplain(isExplain);
		
        return statement;
    }
}

Statement Help(Statement stmt):
{
  
}
{
  {
    return stmt;
  }
}

Statement SetQuery() :
{
  PropertyStatement stmt = new PropertyStatement();
}
{
  (
    "SET" PropertySetQuery(stmt)
  )
  {
    return stmt;
  }
}

Statement XaQuery(Statement stmt):
{
  
}
{
  {
    return stmt;
  }
}


Statement DDLAlertTableQuery():
{
	DDLStatement stmt = new DDLAlertTableStatement();
	Table table = null;
	Token tk = null;
}
{
  (
    tk = < K_ALTER >     {  stmt.setOperate(tk.image);  }
    [<K_IGNORE >]
    tk = <K_TABLE > {  stmt.setTargetName(tk.image);  }
    table = TableReference()
  )
  {
    stmt.setTargetValue(table.toString()); 
    return stmt;
  }
}

Statement DDLRenameTableQuery() :
{
  DDLStatement stmt = new DDLRenameTableStatement();
  Table table = null;
  Token tk = null;
  StringBuilder sb = new StringBuilder();
}
{
  	tk = < K_RENAME> {  stmt.setOperate(tk.image);  }
  	tk = < K_TABLE > {  stmt.setTargetName(tk.image);  }
  	table = TableReference()
  	{ sb.append(table.toString()); } < K_TO > (EntityName() ["." EntityName()]) ("," table = TableReference() { sb.append(table.toString()); } < K_TO >  (EntityName() ["." EntityName()]))*
  	{
  	  stmt.setTargetValue(sb.toString()); 
 	 return stmt;
	}
}

Statement DDLCreateQuery() :
{
  Table table = null;
  Token tk = null;
}
{
  	(
  	  LOOKAHEAD(2)
  	  	(
  	    
	  	  	{
	  	  	  DDLStatement stmt = new DDLCreateTableStatement();
	  	  	}
			(
			  	tk = < K_CREATE> {  stmt.setOperate(tk.image);  }
			  	[[ <K_GLOBAL > | < K_LOCAL > ] <K_TEMPORARY > ] 
				tk = < K_TABLE> {  stmt.setTargetName(tk.image);  }
				[<K_IF_NOT_EXISTS>]
				table = TableReference() 
			)
			
			{
			  	stmt.setTargetValue(table.toString());
		        return stmt;
			}
		)

		|
		
		(
			// \u9417\u89c4\u7569\u7035\u7470\u7ddfsequence\u7487\ue15e\u5f5e
			{
			  DDLCreateSequenceStatenment seqStmt = new DDLCreateSequenceStatenment();
			}
		  	(
		    	tk = < K_CREATE> {  seqStmt.setOperate(tk.image);  }
		    	tk = < K_SEQUENCE > {  seqStmt.setTargetName(tk.image);  }
		    	table = TableReference()
		    	["START WITH"   tk = < INTEGER_LITERAL >   { seqStmt.setStartWith(Long.valueOf(tk.image)); }]
		    	["INCREMENT BY" tk=< INTEGER_LITERAL >  { seqStmt.setOffset(Long.valueOf(tk.image)); }]
		  	)
		  	{
		  	  	seqStmt.setSchema(table.getSchema());
		  	  	seqStmt.setSeqName(table.getName());
				seqStmt.setTargetValue(table.toString());
		    	return seqStmt;
		  	}
		 )	
  )
	
}

Statement DDLDropQuery():
{
  Token tk = null;
  String indexName = null;
  Table table = null;
  StringBuilder sb = new StringBuilder();
}
{
    (
      LOOKAHEAD(2)
	  (
	    (
		    {
	  			DDLStatement stmt = new DDLDropStatement();
		    }
		  	tk = <K_DROP> {  stmt.setOperate(tk.image);  }
			(
			  	tk= <K_VIEW>
			 	|
			 	tk = < K_FUNCTION >
				|
				tk = <K_TRIGGER  >
				|
				tk = < K_DATABASE >
				|
				tk = < K_PROCEDURE> 
			 	|
				[< K_TEMPORARY>] tk=<K_TABLE>
				|
				tk=<K_INDEX> 
			) { stmt.setTargetName(tk.image); }
		
			[<K_IF_EXISTS >]
	
			(
			  LOOKAHEAD(2) indexName = EntityName()  { sb.append(indexName); } < K_ON>  TableReference()
			  | ( table = TableReference() { sb.append(table.toString()); } (","  table = TableReference() { sb.append(","); sb.append(table.toString()); })* ) // [SCHEMA.]TRIGGER/[SCHEMA.]TABLE
			)
	 	)	
		{
		  	stmt.setTargetValue(sb.toString()); 
			return stmt;
		}
	)

	|

	(
		// \u9417\u89c4\u7569\u7035\u7470\u7ddfsequence\u7487\ue15e\u5f5e
		(
		  	{
		    	DDLDropSequenceStatement seqStmt = new DDLDropSequenceStatement();
		  	}
		  	tk = <K_DROP> {  seqStmt.setOperate(tk.image);  }
		  	tk = < K_SEQUENCE > { seqStmt.setTargetName(tk.image); }
		  	table = TableReference()
		)
	
		{
		  	seqStmt.setSchema(table.getSchema());
		  	seqStmt.setSeqName(table.getName());
			seqStmt.setTargetValue(table.toString());
			return seqStmt;
		}
	)
  )
}

Statement DDLTruncateTableQuery():
{
  	Table table = null;
  	Token tk = null;
  	DDLStatement stmt = new DDLTruncateTableStatement();
}
{
	tk = <K_TRUNCATE> {  stmt.setOperate(tk.image);  }
	tk = <K_TABLE> {  stmt.setTargetName(tk.image);  }
	table = TableReference()
	
	{
	  	stmt.setTargetValue(table.toString()); 
		return stmt;
	}
}

Statement SelectSchema() :{
	Token t = null;
	String schema = null;
}{
	<K_USE> (token=<STRING_LITERAL>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<S_QUOTED_IDENTIFIER>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<S_COMMA_IDENTIFIER>{schema = (t.image).substring(1,t.image.length()-1);}
			|t=<IDENTIFIER>{schema = t.image;}){
		PropertyStatement statement = new PropertyStatement();
		statement.addProperty("schema",new ConstantExpression(schema));
		return statement;
	}
}

Statement PropertySetQuery(PropertyStatement statement) :{
	Expression expression = null;
	
	Token name = null;
	Token valueToken = null;
	Comparable value = null;
	String propertyName = null;
}{
	([<K_SESSION> | <K_OPTION> | <K_GLOBAL>] ((<K_TRANSACTION_ISOLATION_LEVEL>(
				<K_TRANSACTION_READ_COMMITTED>{value=Connection.TRANSACTION_READ_COMMITTED;}
				|<K_TRANSACTION_READ_UNCOMMITTED>{value=Connection.TRANSACTION_READ_UNCOMMITTED;}
				|<K_TRANSACTION_SERIALIZABLE>{value=Connection.TRANSACTION_SERIALIZABLE;}
				|<K_TRANSACTION_REPEATABLE_READ>{value=Connection.TRANSACTION_REPEATABLE_READ;}
				)){propertyName = "TRANSACTIONISOLATION";}
			|
			(<K_CLIENT_CHARSET>{propertyName = "charset";} 
				(valueToken = <IDENTIFIER> {value = valueToken.image;}
				| valueToken = <STRING_LITERAL>{value = (valueToken.image).substring(1,valueToken.image.length()-1);}
				|valueToken = <S_QUOTED_IDENTIFIER>{value = valueToken.image;}
				))
			|
			(name = <IDENTIFIER>{propertyName = name.image;}["." name=<IDENTIFIER>{propertyName = propertyName+"."+name.image;}] ["="] (
			valueToken= <K_NULL>{ value = "null";}
			| valueToken= <K_TRUE> {value = Boolean.TRUE;}
			| valueToken= <K_FALSE> {value = Boolean.FALSE;}
			| valueToken = <IDENTIFIER> {value = valueToken.image;}
			| valueToken = <INTEGER_LITERAL>{value = Long.valueOf(valueToken.image);} 
			| valueToken = <STRING_LITERAL>{value = (valueToken.image).substring(1,valueToken.image.length()-1);} //{value = valueToken.image.substring(1,token.image.length()-1);}
			| valueToken = <S_QUOTED_IDENTIFIER>{value = valueToken.image;}
			))
			))["," PropertySetQuery(statement)]{
		if(value != null){
			ConstantExpression consExp= new ConstantExpression(value);
			statement.addProperty(propertyName,consExp);
		}
		return statement;
	}
}

Statement UpdateQuery():
{
	Expression expression = null;
	Table table = null;
	BaseExpressionList andExpression = new AndExpression();
	DMLStatement statement = new UpdateStatement();
	Token parameter = null;
	int index = 0;
}
{
   	(table = UpdateStatement(statement)
    [expression= WhereClause(statement)
    {
      if(expression instanceof BaseExpressionList)
      {
			BaseExpressionList list = (BaseExpressionList)expression;
			andExpression =(BaseExpressionList)expression;
      }else
      {
        	if(expression !=  null)
        	{
				andExpression.addExpression(expression);
			}
      }
      
    } ]

	[<K_LIMIT>
    (parameter = <S_PARAMETER_MARKER>{
      	index = parameterIndex++;
      	if(parameter.image.startsWith("$("))
      	{
			index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
      	}
	   	andExpression.addExpression(new ParameterExpression(index));
	} | <INTEGER_LITERAL>)[("," | <K_OFFSET> ) (parameter = <S_PARAMETER_MARKER>
	{
	  	index = parameterIndex++;
      	if(parameter.image.startsWith("$("))
      	{
			index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
      	}
	   	andExpression.addExpression(new ParameterExpression(index));
	} |<INTEGER_LITERAL> )
    ]])
    {
      	if(andExpression.getSize() >0)
       	{
    		statement.setExpression(andExpression);
   		}
    	return statement;	
    }
}

Statement ShowQuery():
{
	ShowStatement statement = new ShowStatement();
	Expression expression = null;
	Token valueToken = null;
	String schemeName = null;
	Table table = null;
}
{
	(
	  (valueToken = < K_SHOW > 
	  				[		LOOKAHEAD(2)
	  						((<K_SHOW_FULL_TABLES> | < K_SHOW_CREATE_DATABASE > | < K_TABLE_STATUS > | < K_TRIGGERS >) [(<K_FROM >|< K_IN>)] schemeName=EntityName()
	  						{
	  						  	table = new Table();
	  						  	Schema schema = new Schema();
	  						  	schema.setName(schemeName);
	  						  	table.setSchema(schema);
	  						  	table.setName("*");
   	 							tableAliasMap.put(table.toString(),table);	
	  						  	
	  						})
	  						|
	  						((<K_CREATE ><K_TABLE > |<K_SHOW_FULL_COLUMNS>|< K_SHOW_CREATE_PROCEDURE >|< K_SHOW_OPEN_TABLES >) [(<K_FROM >|< K_IN>)] table=TableReference())
	  							  						
	   				]
	 )
   ) [<K_LIKE > SQLExpression(statement)][expression = WhereClause(statement)]
	{
	  if(table != null)
	  {
		statement.setTables(new Table[]{table});
	  }
	
	 statement.setExpression(expression);
	 
	 return statement;
	}
}

Statement CallQuery():
{
	CallStatement statement = new CallStatement();
	Expression expression = null;
}
{
	<K_CALL> expression = SQLExpression(statement){
	  statement.setExpression(expression);
    	return statement;
    }
}

Table UpdateStatement(Statement statement):
{
	Table table = null;
}
{
    ("UPDATE"
    table = TableReference()["," TableReference()]
    "SET" AssignmentClause(statement)){
    	return table;
    }
}

Expression AssignmentClause(Statement statement):
{
	Expression expression = null;
}
{
       (expression= ColumnValues(statement){
       
       
       }
        |  (   "(" UpdateColumn() ("," UpdateColumn())* ")" "=" "(" ( LOOKAHEAD(2) UpdateValues(statement) |  FullSelectStatement(statement) ) ")" )
        ){
        	return expression;
        }
}

void UpdateColumn():
{}
{
    ColumnName()
}

List<Expression> UpdateValues(Statement statement):
{
	Expression expression = null;
	List<Expression> list = new ArrayList<Expression>();
}
{
       expression= UpdateValue(statement){list.add(expression);} ("," expression=UpdateValue(statement){list.add(expression);})*{
       	
       	return list;
       }
}

Expression UpdateValue(Statement statement):
{
Expression expression = null;
}
{
    expression =  SQLSimpleExpression(statement){
      if(statement instanceof DMLStatement)
      {
      		expression = replaceNextOrCurrSequenceValue(expression, (DMLStatement)statement);
	  }
      
       return 	expression;
    }
}

Statement DeleteQuery():
{
	Expression expression = null;
	Table table = null;
	DMLStatement statement = new DeleteStatement();
	AndExpression andExpression = new AndExpression();
	Token parameter = null;
	int index = 0;
}
{
    (
      (table = DeleteStatement()
    [expression = WhereClause(statement)]){
    	if(expression != null)
	  	{
	   		andExpression.addExpression(expression);
	  	}
    	statement.setExpression(expression);
    }
    [ OrderByClause(statement) ]
    [<K_LIMIT>
    (parameter = <S_PARAMETER_MARKER>{
      index = parameterIndex++;
	if(parameter.image.startsWith("$("))
	{
		index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
	}
	   	andExpression.addExpression(new ParameterExpression(index));
	} | <INTEGER_LITERAL>)[("," | <K_OFFSET> ) (parameter = <S_PARAMETER_MARKER>
	{
	  index = parameterIndex++;
		if(parameter.image.startsWith("$("))
		{
			index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
		}
	   	andExpression.addExpression(new ParameterExpression(index));
	} |<INTEGER_LITERAL> )
    ]]
  )
  {
    
 	 return statement;
	}
    
}

Table DeleteStatement():
{
	Table table = null;
}
{
    "DELETE" ["FROM"] table = TableReference(){
    	return table;	
    }
}


Statement InsertQuery():
{
	Table table = null;
	DMLStatement statement = new InsertStatement();
	Expression expression = null;
	List<Column> insertColumns = null;
	List<List<Expression> > insertValues = null;
}
{
    (<K_INSERT>|<K_REPLACE>) [<K_IGNORE >] ["INTO"] table = TableName()
    (([LOOKAHEAD(4) "(" insertColumns = InsertColumns() ")"]
    ( insertValues = InsertValues(statement) | expression = FullSelectStatement(statement))
    {
    	if(insertValues == null || insertValues.size() == 0){
    		statement.setExpression(expression);
    	}else{
    		if(insertColumns != null){
	    		AndExpression andExpression = new AndExpression();
	    		int index = 0;
	    		for(Column column:insertColumns){
	    			
	    			
	    			Expression insertExpression = null;
					if(insertValues.size() >1)
					{
						insertExpression = new OrExpression();
						for(List<Expression> rowExpression : insertValues )
						{
						  	ColumnExpression colExpression = new ColumnExpression();
	    					colExpression.setColumn(column);
						  	ComparisonExpression compExp = new ComparisonExpression();
	    					compExp.setComparison(Comparative.Equivalent);
	    					compExp.setExpression(rowExpression.get(index));
	    					colExpression.setExpression(compExp);
							((OrExpression)insertExpression).addExpression(colExpression);
						}
					}else
					{
					  	ColumnExpression colExpression = new ColumnExpression();
	    				colExpression.setColumn(column);
						ComparisonExpression compExp = new ComparisonExpression();
    					compExp.setComparison(Comparative.Equivalent);
    					compExp.setExpression(insertValues.get(0).get(index));
    					colExpression.setExpression(compExp);
    					insertExpression = colExpression;
					}
	    			andExpression.addExpression(insertExpression);
	    			index ++;
	    		}
	    		statement.setExpression(andExpression);
    		}
    	}
    	
    }
    |
    (
      "SET" expression = AssignmentClause(statement)
    ){statement.setExpression(expression);})

    [<K_ON ><K_DUPLICATE ><K_KEY > <K_UPDATE > AssignmentClause(statement)]
  ){
    	return statement;
    }
}


List<Column> InsertColumns()      :
{
	List<Column> insertColumns = new ArrayList<Column>();
	Column column = null;
}
{
        (column = InsertColumn(){insertColumns.add(column);} ("," column = InsertColumn(){insertColumns.add(column);})*){
        	return insertColumns;
        }
}

//This is just a wrapper to provide different formatting in case of Insert
Column InsertColumn():
{
	Column column = null;
}
{
   column = ColumnName(){
   		return column;
   }
}

List<List<Expression>> InsertValues(Statement statement):
{
	List<List<Expression>> insertValues = new ArrayList<List<Expression > >();
	List<Expression> singleExpressionList = null;
	Expression expression = null;
}
{
       ("VALUES" singleExpressionList = InsertSingleRowValues(statement) {
         	if(singleExpressionList != null)
	       	{
	         	insertValues.add(singleExpressionList);
	       	}
       }(["," ] singleExpressionList = InsertSingleRowValues(statement) {
         	if(singleExpressionList != null)
	       	{
	         	insertValues.add(singleExpressionList);
	       	}
	   })*
	   ){
       	return insertValues;
       }
}


List<Expression> InsertSingleRowValues(Statement statement):
{
	List<Expression> insertValues = new ArrayList<Expression>();
	Expression expression = null;
}
{
	("("  expression = InsertValue(statement){
		if(expression != null)insertValues.add(expression);
	} ("," expression = InsertValue(statement){if(expression != null)insertValues.add(expression);})*  ")")
	{
	  if(insertValues.size() >0)
	  	{
		return insertValues;
		}else
		{
			return null;
		}
	}

}
//This is just a wrapper to provide different formatting in case of Insert
Expression InsertValue(Statement statement):
{
	Expression expression = null;
}
{
 	expression = SQLSimpleExpression(statement){
      if(statement instanceof DMLStatement)
 	  {
  	 	expression = replaceNextOrCurrSequenceValue(expression, (DMLStatement)statement);
  	}
 		return expression;	
 	}
}


Statement SelectQuery():
{
	Expression expression = null;
	DMLStatement statement = new SelectStatement();;
}
{
    (expression = FullSelectStatement(statement)
    (ExtraClauses(statement))*)
    {
    	statement.setExpression(expression);
    	return statement;
    }
    
}


Expression ColumnValues(Statement statement)      :
{
	Expression expression = null;
	AndExpression andExpression = new AndExpression();
}
{
 (expression= ColumnValue(statement){if(expression != null) andExpression.addExpression(expression);} ("," expression = ColumnValue(statement){if(expression != null) andExpression.addExpression(expression);})*){
  return andExpression;
 }
}

Expression ColumnValue(Statement statement)       :
{
ColumnExpression colExpression = new ColumnExpression();
Expression expression = null;
Column column = null;
}
{
       (column= ColumnName() "=" expression = UpdatedValue(statement)){
       	if(expression == null) return null;
       	
       	colExpression.setColumn(column);
       	ComparisonExpression compExp = new ComparisonExpression();
		compExp.setComparison(Comparative.Equivalent);
		compExp.setExpression(expression);
		colExpression.setExpression(compExp);
       	return colExpression;
       }
}


Expression UpdatedValue(Statement statement)      : // Can be a subquery or a expression
{
Expression expression = null;
}
{
  (LOOKAHEAD(("(")+ "SELECT")
  "(" expression = SubSelectStatement(statement) ")"
  |
  expression= SQLSimpleExpression(statement)){
    	if(statement instanceof DMLStatement)
    	{
			expression = replaceNextOrCurrSequenceValue(expression, (DMLStatement)statement);
		}
  	return expression;
  }
}


ComparisonExpression IsNullClause(Statement statement)      :
{
	int comparison = Comparative.Equivalent;
}
{
    (<K_IS> [<K_NOT>{comparison = Comparative.NotEquivalent;}] <K_NULL>)
    {
    	ComparisonExpression comparativeExpression = new ComparisonExpression();
		comparativeExpression.setComparison(comparison);
		comparativeExpression.setExpression(new ConstantExpression(null));	
		return comparativeExpression;
    }
}



/*
*	Tabel Column
*/
Column ColumnName()      :
{
	String schemaName = null;
	String tableName = null;
	String columnName = null;
	Column column =  new Column();
	Table table = null;
}
{
    // schema.table.column
   schemaName = EntityName() [ "." tableName = EntityName() ["." columnName = EntityName()]]{
	   	if(tableName == null){
	   		columnName = schemaName;
	   		schemaName = null;
	   		if(tableStack.size()>0){
	   			table = tableStack.peek();
	   		}
	   	}else{
	   		if(columnName == null){
	   			columnName = tableName;
	   			tableName = schemaName;
	   			schemaName = null;
	   			table = tableAliasMap.get(tableName);
	   		}
	   	}

		/*
		* if column with table name, router can doRoute with this table
		* specially, for global sequence, the sequence name is refer the table name
		*/
		if(table == null)
		{
		  	if(tableName != null && !tableName.equals(""))
		  	{
		  	  	table = new Table();
			  	Schema schema = null;
			  	if(schemaName != null && !schemaName.equals(""))
			  	{
					schema = new Schema();
					schema.setName(schemaName);
			  	}
				
				table.setSchema(schema);
				table.setName(tableName);
                tableAliasMap.put(table.toString(),table);
		  	}
		}
	   	
	   	column.setTable(table);
	   	column.setName(columnName);
	   	return column;
   }
}

String EntityName()      :
{
	Token token = null;
}
{
 	(
 	  ["`"] token =  <IDENTIFIER>{
 		return token.image;
 	}["`"]
)
 	|
 	token =  <S_QUOTED_IDENTIFIER>{
 		return token.image.substring(1,token.image.length()-1);
 	}
 	| token = <S_COMMA_IDENTIFIER>{
 		return token.image.substring(1,token.image.length()-1);	
 	}
}

String Relop():
{
	Token token;
}
{
  (token = "=" | token = "!=" | token = "<>" | token = ">" | token = ">=" |token = "<" |token= "<="){
  	return token.image;
  }
  
}

Table TableName() :
{
	String schemaName = null;
	String tableName = null;
	Table table = null;
	Schema schema = null;
	Token t = null;
	
}
{
  
     (
       schemaName = EntityName()
     ["." 
     	tableName= EntityName()
     ]
   |
	   t = < K_DUAL>
	{
	  schemaName = t.image;
	}
   ){
     	if(tableName == null){
     		tableName = schemaName;
     		schemaName = null;	
     	}
     	table = new Table();
     	table.setName(tableName);
     	if(schemaName != null){
     		schema = new Schema();
     		schema.setName(schemaName);
     		table.setSchema(schema);	
     	}else{
     		table.setSchema(defaultSchema);	
     	}
     	tableAliasMap.put(table.getName(),table);
     	tableStack.push(table);
     	return table;
     }
}

Table TableReference():
{
	Table table = null;
	Token token = null;
}
{
    (
      table = TableName() 
	     [["AS"]
	     (
	     token = <S_COMMA_IDENTIFIER>{
	 		table.setAlias(token.image.substring(1,token.image.length()-1));	
	 	}
		|token = <IDENTIFIER>{
		    	table.setAlias(token.image);
		    }
		  )
		][ INDEX()]
	){
   	 if(table.getAlias() != null){
   	 	tableAliasMap.put(table.getAlias(),table);	
   	 }
   	 tableAliasMap.put(table.toString(),table);	
   	 return table;
   	 }
}

void CaseStatement(Statement statement) :
{}
{
    "CASE" [SQLSimpleExpression(statement)] WhenStatement(statement) (WhenStatement(statement))* [ElseStatement(statement)] "END"
}


void WhenStatement(Statement statement) :
{}
{
	"WHEN" SQLExpression(statement) "THEN" SQLSimpleExpression(statement)
}

void ElseStatement(Statement statement) :
{}
{
	"ELSE" SQLSimpleExpression(statement)
}


void ExtraClauses(Statement statement)       :
{}
{
    (
    	LOOKAHEAD(2) ForUpdateClause()
    	| LOOKAHEAD(2) ReadOnlyClause()
    	| OptimizeForClause()
    	| WithClause()
    	| QuerynoClause()
    	| FetchFirstClause()
    )
}

Expression FullSelectStatement(Statement statement):
{
	Expression expression = null;
	Expression unionedExpression = null;
}
{
	((expression = SubSelectStatement(statement) )
	|
	(
	  "(" expression = FullSelectStatement(statement)")" [ UnionClause() unionedExpression = FullSelectStatement(statement)]
	) ){
		if(unionedExpression != null){
			if(expression == null){
				return unionedExpression;
			}else{
				expression = new OrExpression(expression);
				((OrExpression)expression).addExpression(unionedExpression);
				return expression;
			}
		}else{
			return expression;
		}
	}
}

void UnionClause():
{}
{
        "UNION" ["ALL"]
}

Expression SubSelectStatement(Statement statement):
{
	Expression expression = null;
	Expression fromExpression = null;
	AndExpression andExpression = new AndExpression();
	Token parameter = null;
	int index = 0;
}
{
    (SelectClause(statement)
    [fromExpression = FromClause(statement){
	    if(statement instanceof DMLStatement)
		{
		  	DMLStatement selectFromDual = (DMLStatement)statement;
		  	if(tableStack.size() == 1)
		  	{
		  	  // if the table name is not "DUAL", do not need to do global sequence replace
		  	  Table table = tableStack.peek();
		  	  if(!MysqlSyntaxConstants.DUAL_TABLE_NAME.equalsIgnoreCase(table.getName()))
		  	  {
		  	    selectFromDual.clearSeqColumn();
				selectFromDual.clearBatchSeqFetchCall();
		  	  }
		  	}
		  	else
			{
			  	/* do not need to do grobal sequence replace for select from multiple tables
			  	*  for example: select * from A,B
			  	*/
				selectFromDual.clearSeqColumn();
				selectFromDual.clearBatchSeqFetchCall();
			}
		}
		
		if(fromExpression != null)
		{
		   	andExpression.addExpression(fromExpression);
		}
    }]
    [ expression = WhereClause(statement)
    {
      if(expression != null)
	  {
	   	andExpression.addExpression(expression);
	  }
    }]
    [ GroupByClause(statement) ]
    [ OrderByClause(statement) ]
    [<K_LIMIT>
    (parameter = <S_PARAMETER_MARKER>{
      	index = parameterIndex++;
		if(parameter.image.startsWith("$("))
		{
			index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
		}
	   	andExpression.addExpression(new ParameterExpression(index));
	} | <INTEGER_LITERAL>)[("," | <K_OFFSET> ) (parameter = <S_PARAMETER_MARKER>
	{
	  	index = parameterIndex++;
		if(parameter.image.startsWith("$("))
		{
			index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
		}
	   	andExpression.addExpression(new ParameterExpression(index));
	} |<INTEGER_LITERAL> )
    ]])
    {

      	if(statement instanceof DMLStatement)
		{
		  	DMLStatement selectFromDual = (DMLStatement)statement;
		  	if(tableStack.size() == 0)
		  	{
		  	  	// \u6fe1\u509b\u7049\u5a0c\u2103\u6e41from \u701b\u612c\u5f5e\u6d94\u71b6\u7b09\u93b5\u0446\ue511\u93c7\u630e\u5d32
		  	  	selectFromDual.clearSeqColumn();
				selectFromDual.clearBatchSeqFetchCall();
		  	}
		}

      if(andExpression.getSize() >0)
      {
		return andExpression;
      }else
      {
		return null;
      }
    }
}

void SelectClause(Statement statement):
{}
{
	  "SELECT"
	  [	  "ALL"	  |	  "DISTINCT"	  |	  "DISTINCTROW"	  ]
	  ["HIGH_PRIORITY"]
	  ["STRAIGHT_JOIN"]
	  ["SQL_SMALL_RESULT"]
	  ["SQL_BIG_RESULT"]
	  ["SQL_BUFFER_RESULT"]
	  ["SQL_CACHE" | "SQL_NO_CACHE"]
	  ["SQL_CALC_FOUND_ROWS"] SelectList(statement)
}

/* Checks for whatever follows  SELECT */
void SelectList(Statement statement) :
{}
{
    ("*"("," SelectItem(statement))*) | (SelectItem(statement) ("," SelectItem(statement))*)
}

void SelectItem(Statement statement):
{
	Token token = null;
	Expression expression = null;
	Column column = null;
}
{
    (
        LOOKAHEAD(2) EntityName()".*" /* table.* */
        |   LOOKAHEAD(4) EntityName()"." EntityName() ".*" /* schema.table.* */
        |  LOOKAHEAD(2) expression = SQLSimpleExpression(statement)
        |  expression = FullSelectStatement(statement)
            
    ){
			if(expression instanceof ColumnExpression)
		      {
		        	column = ((ColumnExpression)expression).getColumn();
					((DMLStatement)statement).addSelectColumn(column.getName(),column);

			      if(statement instanceof DMLStatement)
					{
						replaceNextOrCurrSequenceValue(expression, (DMLStatement)statement);
					}
		      }else if(expression instanceof FunctionExpression)
		      {
				 	String columnName = ((FunctionExpression)expression).getFunction().getName();
					column = new Column();
		          	column.setName(columnName);
					((DMLStatement)statement).addSelectColumn(columnName,column);

					Function fun = ((FunctionExpression)expression).getFunction();
					if(statement instanceof  DMLStatement)
					{
						if(fun instanceof BulkValFuntion)
						{
							replaceBatchSeqValue((FunctionExpression)expression, (DMLStatement)statement);
						}
					}
		      }
		
        }// Column or Expression
    [("=" SQLSimpleExpression(statement))] [["AS"]( token = <IDENTIFIER> | token = < S_COMMA_IDENTIFIER > )
    {
      if(token != null)
		{
		  if(column != null)
		  {
		    if(token.image.indexOf("`") == 0)
		    {
				column.setAlias(token.image.substring(1,token.image.length()-1));
		    }else
		    {
				column.setAlias(token.image);
			}
		  }
		}
    }] // Column Alias
}


Expression FromClause(Statement statement) :
{
Expression expression = null;
AndExpression andExpression = null;
Expression currentExpression = null;
}
{
    "FROM" currentExpression = FromItem(statement)
    {
      expression = currentExpression;
    } ( "," currentExpression = FromItem(statement)
    {
      if(currentExpression != null)
      {
    	if(andExpression == null){
    		andExpression = new AndExpression();
    	}
		andExpression.addExpression(currentExpression);
   	  }
    })*
    {
		if(andExpression != null && expression != null)
		{
			andExpression.addExpression(expression);
			return andExpression;
		}else
		{
		  return expression == null?andExpression:expression;
		}

    }
}


Expression FromItem(Statement statement) :
{
Expression expression = null;
AndExpression andExpression = null;
Expression currentExpression = null;
}
{
  expression = TableSpec(statement) (currentExpression = JoinedTable(statement)
  {
	if(currentExpression != null)
      {
    	if(andExpression == null){
    		andExpression = new AndExpression();
    	}
		andExpression.addExpression(currentExpression);
   	  }
  })*
  {
		if(andExpression != null && expression != null)
		{
			andExpression.addExpression(expression);
			return andExpression;
		}else
		{
		  return expression == null?andExpression:expression;
		}
  }
}


Expression JoinedTable(Statement statement) :
{

Expression expression = null;
AndExpression andExpression = null;
Expression currentExpression = null;

}
{
	((["NATURAL"] (("LEFT"|"RIGHT") ["OUTER"])) | (["INNER" | "CROSS"])) "JOIN"
	(LOOKAHEAD(2) expression = TableSpec(statement) (JoinedTable(statement))* | "(" expression = TableSpec(statement) (JoinedTable(statement))* ")")
	[JoinCondition(statement)]
	{
		return expression;
	}
}

Expression TableSpec(Statement statement):
{
	Table table = null;
	Expression expression = null;
}
{
	(
	     table = TableReference()
	| (["TABLE"] "(" expression= FullSelectStatement(statement) ")" [CorrelationClause()])
	)
	{
		return expression;
	}
}

void JoinCondition(Statement statement):
{}
{
     ("ON" SQLExpression(statement))|("USING" "(" SQLExpression(statement) ("," SQLExpression(statement))* ")")
}

Expression WhereClause(Statement statement):
{
	Expression expression;
}
{
    "WHERE" expression = SQLExpression(statement){
    	return expression;
    }
}


void CorrelationClause()       :
{}
{
	["AS"] <IDENTIFIER> [ColumnNames()]
}

void ColumnNames() :
{}
{
	"(" (<IDENTIFIER>|<S_COMMA_IDENTIFIER>) ("," (<IDENTIFIER>|<S_COMMA_IDENTIFIER>))* ")"
}

void GroupByClause(Statement statement) :
{}
{
    "GROUP" "BY" GroupByColumn(statement) ("," GroupByColumn(statement))*
    ["HAVING" SQLExpression(statement)]
}

void GroupByColumn(Statement statement):
{}
{
      SQLRelationalExpression(statement)
}

void OrderByClause(Statement statement):
{}
{
    "ORDER" "BY" OrderByColumn(statement) [(<K_DESC>|<K_ASC>)] ("," OrderByColumn(statement) [(<K_DESC>|<K_ASC>)])*
}


void OrderByColumn(Statement statement):
{}
{
      SQLRelationalExpression(statement)
}


Expression SQLExpression(Statement statement) :
{
	OrExpression orExpression = null;
	AndExpression andExpression = null;
	Expression expression = null;
	Token token;
	int count = 0;
}
{
    expression = SQLAndExpression(statement){
    	orExpression = new OrExpression(expression);
    }
    (
    ("OR" | "||")
		expression =  SQLAndExpression(statement){
			if(expression != null){
				count++;
				orExpression.addExpression(expression);
			}
		}
    )*{
    	if(count >0){
    		return orExpression;
    	}else{
    		return expression;
    	}
    }
}

Expression SQLAndExpression(Statement statement) :
{
	AndExpression andExpression = null;;
	Expression expression;
	Expression currentExpression;
}
{
    expression = SQLUnaryLogicalExpression(statement)
    ( "AND" 
    	currentExpression = SQLUnaryLogicalExpression(statement){
    	
    	if(andExpression == null && currentExpression != null){
    		andExpression = new AndExpression(expression);
    	}
    	if(currentExpression != null){
    		andExpression.addExpression(currentExpression);
    	}
    })*{
    	if(andExpression != null){
    		return andExpression;
    	}else{
    		return expression;
    	}
    	
    }
}

Expression SQLUnaryLogicalExpression(Statement statement) :
{
	Expression expression = null;
	boolean not = false;
}
{
    LOOKAHEAD(2) ExistsClause(statement)
|   (["NOT"{not = true;}]expression= SQLRelationalExpression(statement)){
		return reverseExpression(not,expression);
}
}

Expression ExistsClause(Statement statement) :
{
	Expression expression = null;
	boolean not = false;
}
{
    ["NOT"{not = true;}] "EXISTS" "(" expression = FullSelectStatement(statement) ")"{
    	return reverseExpression(not,expression);
    }
}

Expression SQLRelationalExpression(Statement statement)       :
{
	Expression expression = null;
	Expression otherExpression = null;
	String functionName = null;
	int function = 0;
}
{
    /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */

    (LOOKAHEAD("(" SQLSimpleExpression(statement) ",")
     "(" SQLExpressionList(statement) ")"
|
    (expression = SQLSimpleExpression(statement)))
	
    /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */
   (    functionName = Relop(){
    		function =	Comparative.getComparisonByIdent(functionName);
    	}
    	otherExpression = SQLRelationalOperatorExpression(statement)
   			{
   				if(expression == null ||  otherExpression == null){
   					return null;	
   				}
   				
		   		if(expression instanceof ColumnExpression && !(otherExpression instanceof ColumnExpression)){
		   			ColumnExpression colExp = (ColumnExpression)expression;
		   			ComparisonExpression comparativeExpression = new ComparisonExpression();
		   			comparativeExpression.setComparison(function);
		   			comparativeExpression.setExpression(otherExpression);
		   			colExp.setExpression(comparativeExpression);
		   			return colExp;
		   		}else if(!(expression instanceof ColumnExpression) && (otherExpression instanceof ColumnExpression)){
		   			ColumnExpression colExp = (ColumnExpression)otherExpression;
		   			ComparisonExpression comparativeExpression = new ComparisonExpression();
		   			comparativeExpression.setComparison(Comparative.exchangeComparison(function));
		   			comparativeExpression.setExpression(expression);
		   			colExp.setExpression(comparativeExpression);
		   			return colExp;
		   		}else{
		   			return null;
		   		}
   			}
        |  LOOKAHEAD(2) (otherExpression=SQLInClause(expression,statement)
	        {
	        	return otherExpression;
	        })
        |  LOOKAHEAD(2) (otherExpression=SQLBetweenClause(expression,statement){
        	return otherExpression;
        })
        |  LOOKAHEAD(2) (otherExpression = SQLLikeClause(statement)){
        	if(expression instanceof ColumnExpression && otherExpression != null){
    			ColumnExpression colExp = (ColumnExpression)expression;
    			colExp.setExpression((ComparisonExpression)otherExpression);
    			return colExp;
    		}else{
    			return null;	
    		}
        }
        |  LOOKAHEAD(2)(otherExpression = IsNullClause(statement){
    		if(expression instanceof ColumnExpression && otherExpression != null){
    			ColumnExpression colExp = (ColumnExpression)expression;
    			colExp.setExpression((ComparisonExpression)otherExpression);
    			return colExp;
    		}else{
    			return null;	
    		}
        })
   )?{
   		return expression;
   }
}

List<Expression> SQLExpressionList(Statement statement)       :
{
	List<Expression> list = new ArrayList<Expression>();
	Expression expression;
}
{
   expression = SQLSimpleExpression(statement){
   	list.add(expression);
    	
    } ("," expression = SQLSimpleExpression(statement){
    		list.add(expression);
    })*{
    	return list;	
    }
}

Expression SQLRelationalOperatorExpression(Statement statement)        :
{
	
	Expression expression = null;
	String functionName;
	int function;
}
{

    /* Only after seeing an ANY/ALL or "(" followed by a FullSelectStatement() we can
    determine that is is a sub-query
    */
    (   LOOKAHEAD("ANY" | "ALL" | "(" "SELECT")
        (["ALL" | "ANY"] "(" FullSelectStatement(statement) ")")
        |
        expression = SQLSimpleExpression(statement)
    )
    {
    	return expression;
    }
}

Expression SQLInClause(Expression inputExpression,Statement statement)      :
{
	boolean not = false;
	Expression expression = null;
	List<Expression> list = null;
	
}
{
    ["NOT"{not = true;}] "IN" "(" (LOOKAHEAD(2) list=SQLExpressionList(statement) | expression = FullSelectStatement(statement)) ")" {
    	
    	if(list == null){
    		return expression;	
    	}
    	if(list.size()==1){
    		
    		Expression item = list.get(0);
    		ComparisonExpression comparativeExpression = new ComparisonExpression();
    		comparativeExpression.setExpression(item);
    		comparativeExpression.setComparison(not?Comparative.NotEquivalent:Comparative.Equivalent);
	    		
    		if(inputExpression instanceof ColumnExpression){
				((ColumnExpression)inputExpression).setExpression(comparativeExpression);
				return 	inputExpression;
    		}else{
    			return comparativeExpression;
    		}
    		
    	}else{
    		BaseExpressionList baseList = null;
    		if(not){
    			baseList = new AndExpression(null);
    		}else{
    			baseList = new OrExpression(null);
    		}
    		
	    	for(Expression item:list){
	    		
	    		ComparisonExpression comparativeExpression = new ComparisonExpression();
    			comparativeExpression.setExpression(item);
    			comparativeExpression.setComparison(not?Comparative.NotEquivalent:Comparative.Equivalent);
	    		if(inputExpression instanceof ColumnExpression){
	    			ColumnExpression columnExpression = new ColumnExpression();
	    			columnExpression.setExpression(comparativeExpression);
	    			columnExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
		    		baseList.addExpression(columnExpression);
	    		}else{
	    			baseList.addExpression(comparativeExpression);
	    		}
	    	}
	    	return baseList;
    	}
    }
}

Expression SQLBetweenClause(Expression inputExpression,Statement statement)      :
{
	boolean not = false;
	Expression minExpression = null;
	Expression maxExpression = null;
	
}
{
    ["NOT"{not = true;}] "BETWEEN" minExpression = SQLSimpleExpression(statement) "AND" maxExpression = SQLSimpleExpression(statement){

		if(minExpression != null && maxExpression != null)
		{
	    	ComparisonExpression comparativeMinExpression = new ComparisonExpression();
	    	comparativeMinExpression.setExpression(minExpression);
	    	comparativeMinExpression.setComparison(Comparative.GreaterThanOrEqual);
	    	
	    	ComparisonExpression comparativeMaxExpression = new ComparisonExpression();
	    	comparativeMaxExpression.setExpression(maxExpression);
	    	comparativeMaxExpression.setComparison(Comparative.LessThanOrEqual);
	    	AndExpression andExpression = new AndExpression();
	    	if(inputExpression instanceof ColumnExpression){
	    		ColumnExpression columnMinExpression = new ColumnExpression();
				columnMinExpression.setExpression(comparativeMinExpression);
				columnMinExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
				
				ColumnExpression columnMaxExpression = new ColumnExpression();
				columnMaxExpression.setExpression(comparativeMaxExpression);
				columnMaxExpression.setColumn(((ColumnExpression)inputExpression).getColumn());
				
				andExpression.addExpression(columnMinExpression);
				andExpression.addExpression(columnMaxExpression);
	    	}else{
	    		andExpression.addExpression(comparativeMinExpression);
	    		andExpression.addExpression(comparativeMaxExpression);
	    	}
    	
			return reverseExpression(not,andExpression);
		}else
		{
			return null;
		}
    }
}

Expression SQLLikeClause(Statement statement)      :
{
	Expression expression = null;
	boolean not = false;
}
{
	["NOT"{not = true;}] "LIKE" expression = SQLSimpleExpression(statement){
		ComparisonExpression comparisonExpression = new ComparisonExpression();
		comparisonExpression.setExpression(expression);
		comparisonExpression.setComparison(not?Comparative.NotLike:Comparative.Like);
		return comparisonExpression;	
	}
}

Expression SQLSimpleExpression(Statement statement)      :
{
	Expression expression = null;
	Token token = null;
}
{
    (expression= SQLAddSubtractExpression(statement)){
    	
    	return expression;	
    } 
}

Expression SQLAddSubtractExpression(Statement statement)      :
{
	Expression expression = null;
	Expression otherExpression = null;
	Token token = null;
	Function function;
	FunctionExpression superExpression = null;
}
{
       (expression = SQLMultiplicativeExpression(statement) ((token = "+" | token = "-"  | token = "|" | token = "&")
       otherExpression = SQLMultiplicativeExpression(statement){
         String ident = token.image.toUpperCase();
         	
		    function = getFunction(ident);
		    if(function == null) return null;
		    FunctionExpression functionExpression = new FunctionExpression();
		    functionExpression.setFunction(function);
       		if(superExpression == null){
       			functionExpression.addArgExpression(expression);
		    	functionExpression.addArgExpression(otherExpression);
       		}else{
       			functionExpression.addArgExpression(superExpression);
       			functionExpression.addArgExpression(otherExpression);
       		}
       		superExpression = functionExpression;
       })*){
       		if(superExpression == null){
       			return expression;
       		}else{
       			return superExpression;
       		}
       }
}



Expression SQLMultiplicativeExpression(Statement statement)      :
{
	FunctionExpression functionExpression;
	Expression expression;
	Expression otherExpression;
	Token token;
}
{
  expression = SQLUnaryExpression(statement) ( (token = "*" | token = "/"  | token= "%" | token = "MOD" | token = "DIV" ) otherExpression = SQLUnaryExpression(statement){
  	Function function = getFunction(token.image.toUpperCase());
  	if(function != null && expression != null && otherExpression != null){
	  	functionExpression = new FunctionExpression();
	    functionExpression.setFunction(function);
	    functionExpression.addArgExpression(expression);
	    functionExpression.addArgExpression(otherExpression);
	    expression = functionExpression;
  	}
  	
  })*{
  	return expression;
  }
}


/**
void SQLExpotentExpression() #void:
{}
{
    SQLUnaryExpression() //( "**" SQLUnaryExpression())*
}
**/

Expression SQLUnaryExpression(Statement statement)      :
{
	Expression expression;
	boolean isSub = false;
}
{
    ["+" | "-"{isSub=true;}] expression = SQLPrimaryExpression(statement){
    	if(isSub){
    		Function function = getFunction("-");
    		if(function != null){
	    		FunctionExpression funExp = new FunctionExpression();
	    		ConstantExpression consExp = new ConstantExpression(0);
	    		funExp.addArgExpression(consExp);
	    		funExp.addArgExpression(expression);
	    		funExp.setFunction(function);
	    		return funExp;
    		}else{
    			return null;	
    		}
    	}
    	return expression;
    }
}


Expression SQLPrimaryExpression(Statement statement)      :
{
	Token t = null;
	Column column = null;
	Expression expression = null;
	Comparable value = null;
	boolean not = false;
	Token parameter = null;
	int index = 0;
}
{(
t=<K_NULL>{
	return new ConstantExpression(null);
}
|t=<K_TRUE> {
		return new ConstantExpression(Boolean.TRUE);
	}
|	t=<K_FALSE> {
		return new ConstantExpression(Boolean.FALSE);
	}
|   t=<INTEGER_LITERAL>{
	
		try {
			value = Long.valueOf(t.image);
		} 
		catch (Exception e) {
		}
	return new ConstantExpression(value);
}
|   t=<FLOATING_POINT_LITERAL> {
	try {
		value = new BigDecimal(t.image);
	} 
	catch (Exception e) {
	}
	return new ConstantExpression(value);
}

|  t= <STRING_LITERAL>{
	// strip away double quotes at end of string
	String temp  = null;
	if(t.image.indexOf("_x") ==0)
	{
		temp = (t.image).substring(2,t.image.length()-1);
	}else
	{
		temp = (t.image).substring(1,t.image.length()-1);
	}
		// replace escape characters
		temp = replaceEscape(temp);
		return new ConstantExpression(temp);
}
|  parameter = <S_PARAMETER_MARKER>{
	index = parameterIndex++;
	if(parameter.image.startsWith("$("))
	{
		index = Integer.parseInt(parameter.image.substring(2,parameter.image.length()-1));
	}
	return new ParameterExpression(index);
}
| ("INTERVAL" expression=SQLExpression(statement) (token = "YEAR" | token = "MONTH" | token = "DAY" | token = "HOUR" | token = "MINUTE" | token = "SECOND" | token = "MICROSECOND")){
		if(token != null){
    		int field = -1;
    		if(token.image.equalsIgnoreCase("YEAR")){
    			field = Calendar.YEAR;
    		}else if(token.image.equalsIgnoreCase("MONTH")){
    			field = Calendar.MONTH;
    		}else if(token.image.equalsIgnoreCase("DAY")){
    			field = Calendar.DATE;
    		}else if(token.image.equalsIgnoreCase("WEEK")){
    			field = Calendar.DATE;
    			FunctionExpression funExp = new FunctionExpression();
    			funExp.setFunction(this.getFunction("*"));
    			funExp.addArgExpression(expression);
    			funExp.addArgExpression(new ConstantExpression(7));
    			expression = funExp;
    		}else if(token.image.equalsIgnoreCase("HOUR")){
    			field = Calendar.HOUR;
    		}else if(token.image.equalsIgnoreCase("MINUTE")){
    			field = Calendar.MINUTE;
    		}else if(token.image.equalsIgnoreCase("SECOND")){
    			field = Calendar.SECOND;
    		}else if(token.image.equalsIgnoreCase("MICROSECOND")){
    			field = Calendar.MILLISECOND;
    			FunctionExpression funExp = new FunctionExpression();
    			funExp.setFunction(this.getFunction("/"));
    			funExp.addArgExpression(expression);
    			funExp.addArgExpression(new ConstantExpression(1000));
    			expression = funExp;
    		}
    		FunctionExpression funExp = new FunctionExpression();
    		funExp.setFunction(timeConverter);
    		funExp.addArgExpression(expression);
    		return funExp;
    	}
}
|   CastFunctionCall(statement)
|   CaseStatement(statement)
|   ["!"{not = true; }]LOOKAHEAD({ getFunction(getToken(1).image.toUpperCase())!= null }) expression = OverloadedFunctionCall(statement)
	{
	  if(not && expression != null)
	  {
	   	 expression = reverseExpression(not,expression);
	  }
	}
|   ("(" expression=SQLExpression(statement) ")")
|   LOOKAHEAD(EntityName() [ "." EntityName() ["." EntityName()]] "(" ) expression = FunctionCall(statement)
|  column = ColumnName(){
	ColumnExpression columnExpression = new ColumnExpression();
	columnExpression.setColumn(column);
	return 	columnExpression;
}){
	return expression;
}
}
Expression FunctionCall(Statement statement)       :
{
	String schemaName = null;
	String seqName = null;
	String funcName = null;
	List<Expression > argExps = null;
	FunctionExpression funExp = null;

	Table table = null;
	Schema schema = null;
	
}
{
    // caters the following
    // function(args)
    // package.function(args)
    // user.package.function(args)

    // however note that "distinct/all/*" can be only used with
    // inbuilt functions but no distinction is made between inbuilt
    // function and custom functions

    schemaName = EntityName() [ "." seqName = EntityName() ["." funcName = EntityName()]]
    {
      if(seqName == null){
	   		funcName = schemaName;
	   		schemaName = null;
	   	}else{
	   		if(funcName == null){
	   			funcName = seqName;
	   			seqName = schemaName;
	   			schemaName = null;
	   		}
	   	}

	   	if(funcName.equalsIgnoreCase(SeqConstants.BULKVAL))
	   	{
	   	  funExp = new FunctionExpression();
	   	  BulkValFuntion bulkValFunc = new BulkValFuntion();
	   	  bulkValFunc.setName(funcName);

     	  table = new Table();
     	  table.setName(seqName);

     	  if(schemaName != null){
     		schema = new Schema();
     		schema.setName(schemaName);
     		table.setSchema(schema);	
     	  }
			
		  bulkValFunc.setTable(table);
	   	  funExp.setFunction(bulkValFunc);
	   	}
	   	
    }
    "(" [["DISTINCT" | "ALL"] (argExps = SQLExpressionList(statement)
    {
      if(argExps.size() == 1)
      {
        Expression argExp = argExps.get(0);
        if(argExp instanceof ConstantExpression)
        {
            if(funExp != null)
      		{
        		funExp.setArgList(argExps);
      		}
        }
        else
        {
			funExp = null;
        }
      }
      else
      {
        funExp = null;
      }
    }
    | "*")] ")"
    {
      if(argExps == null || argExps.isEmpty()) funExp = null;
      return funExp;
    }
}


void CastFunctionCall(Statement statement)      :
{}
{
	//Cast funciton in DB2 is very different from all other functions
	"CAST" "(" SQLSimpleExpression(statement) "AS" DataTypes() ")"
}

String FunctionName() :
{
  Token t = null;
}
{
	(t=<K_INSERT>
	| t=<K_MOD>
	| t=<K_MICROSECOND>
	| t=<K_YEAR>
	| t=<K_DAY>
	| t=<K_MINUTE>
	| t=<K_MONTH>
	| t=<K_HOUR>
	| t=<K_SECOND>
	| t=<K_REPLACE>
	|t=<IDENTIFIER>
	)
	{
		if(t != null){
			return t.image.toUpperCase();
		}else{
			return null;	
		}
	}
}

//This covers all over loaded functions that are using keyword and can not be captured by
//generic function defination
Expression OverloadedFunctionCall(Statement statement)      :
{
	Expression expression = null;
	Function function = null;
	Token functionNameToken = null;
	String functionName = null;
	FunctionExpression funExpression = null;
	boolean nullExp = false;
	
}
{
	 functionName = FunctionName(){
		funExpression = new FunctionExpression();
		function = getFunction(functionName);
		funExpression.setFunction(function);
	}
	(["(" [ expression = SQLSimpleExpression(statement){
			if(funExpression != null){
				if(expression == null){
					nullExp = true;
				}
				funExpression.addArgExpression(expression);
			}
		 }] ("," expression = SQLSimpleExpression(statement){
			if(funExpression != null){
				if(expression == null){
					nullExp = true;
				}
				funExpression.addArgExpression(expression);
			} 	
		})* ")"]){
			if(nullExp){
				return null;	
			}else{
			  return funExpression;
			}
		}	
}

void DataTypes()      :
{}
{
    (       "CHAR"
        |   "VARCHAR"
        |   "VARCHAR2"
        |   "DECIMAL"
        |   "INTEGER"
        |   "INT"
        |   "NUMBER"
        |   "NUMERIC"
        |   "REAL"
        |   "FLOAT"
    ) [ "(" <FLOATING_POINT_LITERAL> [ "," <FLOATING_POINT_LITERAL> ] ")" ]

    |   "DATE"
    |   "TIME"
    |   "TIMESTAMP"
    |   "BOOLEAN"
}

void ForUpdateClause() :
{}
{
    "FOR" "UPDATE" ["OF" ColumnName() ("," ColumnName())*] [<K_NOWAIT>]
}

void ReadOnlyClause() :
{}
{
	"FOR" ("FETCH" | "READ") "ONLY"
}

void INDEX() :
{}
{
 ("FORCE INDEX" |"IGNORE INDEX" | "USE INDEX") "(" <IDENTIFIER> ( "," <IDENTIFIER>)* ")"
}

void OptimizeForClause() :
{}
{
	"OPTIMIZE" "FOR" <FLOATING_POINT_LITERAL> (<IDENTIFIER>|<S_COMMA_IDENTIFIER>)

}

void WithClause() :
{}
{
	"WITH" (<IDENTIFIER>|<S_COMMA_IDENTIFIER>) [<IDENTIFIER> <IDENTIFIER> <IDENTIFIER>]
}

void QuerynoClause() :
{}
{
	"QUERYNO" <FLOATING_POINT_LITERAL>
}

void FetchFirstClause() :
{}
{
	"FETCH" <IDENTIFIER> [<FLOATING_POINT_LITERAL>] <IDENTIFIER> "ONLY"
}
